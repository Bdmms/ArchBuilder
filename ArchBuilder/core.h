#pragma once

#ifndef ARCH_CORE_H
#define ARCH_CORE_H

#include <vector>
#include <iostream>
#include <fstream>
#include <immintrin.h>

typedef unsigned long u64;	// 64-bit Integer
typedef unsigned int u32;	// 32-bit Integer
typedef unsigned short u16;	// 16-bit Integer
typedef unsigned char u8;	// 8-bit Integer

namespace arc 
{
	// Deletes all pointers generated by functions in the namespace if AUTO_GARBAGE_COLLECTION is defined
	void cleanUp();

	// Reverses the endian of a 16-bit integer
	constexpr u16 REu16(u16 x) { return ((x & 0xFF00) >> 8) | ((x & 0xFF) << 8); }
	// Reverses the endian of a 32-bit integer
	constexpr u32 REu32(u32 x) { return ((x & 0xFF000000) >> 24) | ((x & 0xFF0000) >> 8) | ((x & 0xFF00) << 8) | ((x & 0xFF) << 24); }
	// Interrprets the 1st 4 characters of a string as an integer
	constexpr u32 ID(const char* str) { return *((u32*)str); }

	// An integer based exponential function
	constexpr int ipow(const int x, const int p)
	{
		if (p < 0) return 0;
		int product = x;
		for (int i = 1; i < p; i++)
			product *= x;
		return product;
	}

	// A floating point base exponential function with an integer exponent
	constexpr float fpow(const float x, const int p);

	// Prints a string that lacks a terminating character
	constexpr void cprint(const char* str, const u32 sz);
	// Prints a string that lacks a terminating character and breaks to the next line
	void cprintln(const char* str, const u32 sz);

	// Converts an integer into hexadecimal using a fixed size
	const char* toHex(const u32 x, const unsigned char& b);
	// Concatenates an array of strings
	const char* concat(const char** strArr, const size_t sz);
	// Returns whether the two strings are equal up to a specified length
	constexpr bool equals(const char* a, const char* b, const u32 sz);

	struct vec8
	{
		__m256 vec;
		vec8() { vec = _mm256_set1_ps(0.0f); }
		vec8(const __m256& v) : vec(v) {}
		vec8(const float& value) { vec = _mm256_set1_ps(value); }

		inline void setoffset(const float& value, const float& offset);

		float& operator[](const u32& i) { return vec.m256_f32[i]; }
		void operator*=(const vec8& v) { vec = _mm256_mul_ps(vec, v.vec); }
		void operator/=(const vec8& v) { vec = _mm256_div_ps(vec, v.vec); }
		void operator+=(const vec8& v) { vec = _mm256_add_ps(vec, v.vec); }
		void operator-=(const vec8& v) { vec = _mm256_sub_ps(vec, v.vec); }
		void operator=(const float& value) { vec = _mm256_set1_ps(value); }
	};

	struct vec4
	{
		__m256d vec;
		vec4() { vec = _mm256_set1_pd(0.0); }
		vec4(const __m256d& v) : vec(v) {}
		vec4(const double& value) { vec = _mm256_set1_pd(value); }

		void setoffset(const double& value, const double& offset);

		double& operator[](const u32& i) { return vec.m256d_f64[i]; }
		void operator*=(const vec4& v) { vec = _mm256_mul_pd(vec, v.vec); }
		void operator/=(const vec4& v) { vec = _mm256_div_pd(vec, v.vec); }
		void operator+=(const vec4& v) { vec = _mm256_add_pd(vec, v.vec); }
		void operator-=(const vec4& v) { vec = _mm256_sub_pd(vec, v.vec); }
		void operator=(const double& value) { vec = _mm256_set1_pd(value); }
	};

	vec8 operator+(const vec8& v1, const vec8& v2);
	vec8 operator-(const vec8& v1, const vec8& v2);
	vec8 operator/(const vec8& v1, const vec8& v2);
	vec8 operator*(const vec8& v1, const vec8& v2);
	vec8 operator*(const vec8& vec, const float& value);

	vec4 operator+(const vec4& v1, const vec4& v2);
	vec4 operator-(const vec4& v1, const vec4& v2);
	vec4 operator/(const vec4& v1, const vec4& v2);
	vec4 operator*(const vec4& v1, const vec4& v2);
	vec4 operator*(const vec4& vec, const double& value);
};

#endif